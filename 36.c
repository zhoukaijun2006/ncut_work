//【问题描述】
//  若两个正整数的乘积，等于两正整数各自逆序后的乘积，则称其为逆序乘积式。编写程序读入两个正整数，
//  然后判断这两个正整数能否构成逆序乘积式。假设两个正整数的乘积不会超过(int)数据类型的表示范围。
//【输入形式】
//  从控制台输入以一个空格分隔的两个正整数。
//【输出形式】
//  若两个正整数能够构成逆序乘积式，则输出两个正整数及其逆序的乘积形式，并且中间用一个等号相连；
//  若不能构成逆序乘积式，则输出两个正整数及其逆序的乘积形式，并且中间用一个不等号相连。
//  注意：输出的字符之间没有空格分隔。若逆序后最高位为0，则为0的最高位不输出。
//【样例输入1】
//  12 693
//【样例输出1】
//  12 * 693 = 21 * 396
//【样例1说明】
//  输入的两个正整数为12和693，其乘积为8316。将这两个正整数逆序后分别为21和396，其乘积为8316。两者乘积相等，所以输出12 * 693 = 21 * 396。
//【样例输入2】
//  185 1300
//【样例输出2】
//  185 * 1300 != 581 * 31
//【样例2说明】
//  输入的两个正整数为185和1300，其乘积为240500。将这两个正整数逆序后分别为581和31，其乘积为18011。
//  两者乘积不相等，所以输出185 * 1300 != 581 * 31。

//#define _CRT_SECURE_NO_WARNINGS
//#include<stdio.h>
//#include<math.h>
//int digit(int x, int n)
//{
//	return x % (int)pow(10, n) / (int)pow(10, n - 1);
//}
//int reverse(int n)
//{
//	int len = (int)log10(n) + 1;
//	int sum = 0;
//	for (int i = 1; i <= len; i++)
//	{
//		sum += digit(n, i) * (int)pow(10, len - i);
//	}
//	return sum;
//}
//int main()
//{
//	int m, n;
//	scanf("%d %d", &m, &n);
//	if (m * n == reverse(m) * reverse(n))
//	{
//		printf("%d*%d=%d*%d", m, n, reverse(m), reverse(n));
//	}
//	if (m * n != reverse(m) * reverse(n))
//	{
//		printf("%d*%d!=%d*%d", m, n, reverse(m), reverse(n));
//	}
//	return 0;
//}